<html><head>
<title>HowToSSG:バイト列</title>
<BASE TARGET="_self">
<LINK REL=STYLESHEET TYPE="text/css" HREF="../style.css">
</head><BODY>


<table class="difficultBOX">
<tr><td class="difficultLevel">難解度「AA」</td></tr>
<tr><td>
※このページ全体の難解度です。
</td></tr>
</table>

<TABLE CLASS=titleBOX><TR><TD>バイト列</TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER=0 bgcolor="#FFFFE0"><TR><TD>
　トグル系項目に限らず、ファンネルライトやダブルリストなどでも広く用いられる「バイト列」ですが、これはバイト単位で記述した処理の集まりです。例を示します。
<table CLASS=exaBOX><tr><td NOWRAP>
2EFFC0E0<BR>
2E FF   C0E0<BR>
2? DD ??<BR>
5E *+ 02 1FFF DD<BR>
5E *+ 04 1FFFFFFF DD<BR>
*&lt; FF :: 01 *&gt;<BR>
*&lt; FF :: 01 :: FF *&gt;
*: 00500000 FF<BR>
*_ 01?00010<BR>
$4 [:0x400000:]+0x500 $$<BR>
*{ FF :: 01 *}<BR>
*{ FF :: 01 :: FF *}<BR>
*[ 0x20 :: FF00 *]<BR>
&lt;_ A020 :: FFCC _&gt;<BR>
</td></tr></table>
　バイト列では、値は全て16進数ですので、「0x」を付ける必要はありません。また、16進数といっても、「9」や「A」のように1桁で表せるものは「09」「0A」として、必ず2文字区切りにしてください。なお、1バイトスペースは無視されますので、例の1行目と2行目は同じものになります。
<table CLASS=flameBOX>
<tr><td CLASS=flameTD NOWRAP>2EFFC0E0</td><td>
16進数の2E, FF, C0, E0 が連続していることを意味しています。書き込み処理なら、この通りに書き込まれます。</td></tr>
<tr><td CLASS=flameTD NOWRAP>2E FF   C0E0</td><td>
1バイトスペースは無視されますので、「2EFFC0E0」と同義です。</td></tr>
<tr><td CLASS=flameTD NOWRAP>2? ?D ??</td><td>
'?'によるマスクも可能です。比較処理なら、「2?」は、20〜2F のどれにでも合致します。書き込み処理なら、「2?」は、一旦現在の値を所得し、2FとのANDを取ってマスクされた値を書き込みます。「?D」「??」も同様に解釈されます。</td></tr>
<tr><td CLASS=flameTD NOWRAP>5E *+ 02 1FFF DD</td><td>
"*+"は、相対ジャンプ命令です。
<table CLASS=exaBOX><tr><td NOWRAP>
*+ 使用バイト数 ジャンプバイト数
</td></tr></table>
という書式で書きます。<BR>
仮に処理開始のアドレスを0x400000 とすると、ここでは、<BR>
アドレス0x400000 に5E を処理して1バイト進み、<BR>
ジャンプ命令によって1FFFバイト進め、<BR>
アドレス0x402000 にDD を処理する。というバイト列になります。
</td></tr>
<tr><td CLASS=flameTD NOWRAP>5E *+ 04 1FFFFFFF DD</td><td>
ジャンプ命令(*+)を、4バイトのジャンプ量で使用した例です。<BR>
注意点として、ジャンプ量は<b>リトルエンディアン</b>表記になります。4バイトのジャンプ量指定で0x2Fしか飛ばさない場合、「*+ 04 0000002F」といった書き方になるわけです。</td></tr>
<tr><td CLASS=flameTD NOWRAP>*&lt; FF :: 01 *&gt;</td><td>
<table class="difficultBOX">
<tr><td class="difficultLevel">難解度「AA+」</td></tr>
<tr><td>
"*&lt;"は、条件分岐命令です。　
<table CLASS=exaBOX><tr><td NOWRAP>
*&lt; 条件式のバイト列 :: 真のとき処理するバイト列<br>　　　　　　　　　　:: 偽のとき処理するバイト列 *&gt;<br>
<FONT 
color=#c06000>////////////////////　↑実際は一行で書きます</FONT>
</td></tr></table>
という書式で書きます。偽のとき処理するバイト列は、必要が無ければ直前の「::」と併せて省いて構いません。<BR>
仮に処理開始のアドレスを0x400000 とすると、ここでは、<BR>
アドレス0x400000 の値がFF であれば、<BR>
アドレス0x400001 に01 を処理する。というバイト列になります。（FFでない場合は、何もしません）<BR>
　ただし、ここでいう「条件分岐」は、「経路分岐」にあたります。下の表を見て下さい。
<table border="0">
<tr><td bgcolor="#808080" colspan="3"> </td></tr>
<tr><td bgcolor="#808080"> </td><td bgcolor="#FFC0C0"><font color="#0000FF">AA</font> BB 3F 3F</td><td bgcolor="#808080"> </td></tr>
<tr><td bgcolor="#FFC0C0">→DD EE</td><td bgcolor="#808080" colspan="2"> </td></tr>
<tr><td bgcolor="#808080"> </td><td bgcolor="#FFC0C0">55 CC 20 44</td><td bgcolor="#808080"> </td></tr>
<tr><td bgcolor="#808080" colspan="3"> </td></tr>
</table>
　<font color="#FF0000">"DD EE"</font>と続くメモリデータがあったとき、その次のメモリデータが<font color="#0000FF">"AA"</font>のときと、それ以外のときで、以降の処理を分けたいとしましょう。このようなときに、経路分岐型の条件分岐命令を用います。<BR>
今回の例で言えば、“<font color="#0000FF">DD EE *&lt; AA :: BB 3F 3F :: CC 20 44 *&gt;</font>”などといった形になるでしょう。注意して欲しいのは、もしこのバイト列で書き込み処理を行った場合、3バイト目の値が<font color="#0000FF">"AA"</font>のときは、4バイト目からBB 3F 3Fに書き換え、<b>3バイト目</b>がAAでないときは、同じく<b>4バイト目</b>からCC 20 44と書き換えます。<b><font color="#FF0000">「条件式を評価した結果、読み書きを行うアドレスは、条件式で評価したメモリデータの次から」</font></b>なのです。<BR>
　※あるアドレスの値がFFなら、そのアドレスの値を00に書き換えたい、といった処理は、経路分岐型の条件分岐ではなく、後述する「条件付き置換」を利用します。
</td></tr>
</table>
</td></tr>
<tr><td CLASS=flameTD NOWRAP>*&lt; FF :: 01 :: FF *&gt;</td><td>
条件式の偽の処理も行う場合の例です。<BR>
仮に処理開始のアドレスを0x400000 とすると、ここでは、<BR>
アドレス0x400000 の値がFF であれば、<BR>
アドレス0x400001 に01 を処理し、FF でないなら<BR>
アドレス0x400001 にFF を処理する。というバイト列になります。
</td></tr>
<tr><td CLASS=flameTD NOWRAP>*: 00500000 FF</td><td>
「*+」が相対ジャンプ命令であることは前述しましたが、「*:」は絶対ジャンプ命令です。絶対ジャンプは直接アドレスを指定するため、続くバイトは4バイト固定です。
<table CLASS=exaBOX><tr><td NOWRAP>
*: ジャンプ先アドレス
</td></tr></table>
という書式を用います。この例では、呼び出し元の項目がどんなアドレスを指定していようとも、アドレス0x500000に、FFを書き込む処理を指します。
</td></tr>
<tr><td CLASS=flameTD NOWRAP>*_ 01?00010</td><td>
　バイト列では、16進数表記のためにデータをバイト単位で記述していきますが、この場合、ビット単位のマスク処理を記述することが出来ません。そこで、バイトではなくビット単位で値を書くときに、ビット展開命令「*_」を使用します。<BR>
　「*_」と書くと、その後ろから8文字分を、マスクを考慮しながら1バイトに組み直します。なお、<font color="#FF0000">上位のビットから順に記述します</font>。(8→001000)<BR>
<table CLASS=exaBOX><tr><td NOWRAP>
*_ 展開したビット値
</td></tr></table>
　という書式を用います。当たり前ですが、展開したビット値を記述するので、 0 か 1 か ? しか使えません。
</td></tr>
<tr><td CLASS=flameTD NOWRAP>$4 [:0x400000:]+0x500 $$</td><td>
<table class="difficultBOX">
<tr><td class="difficultLevel">難解度「AA+」</td></tr>
<tr><td>
　'*'から始まる命令群は、「組み替え型」の命令になります。条件分岐やアドレスの移動、ビット展開などがそれにあたりますね。これとは別に、'$'から始まる命令もあり、これらは「置き換え型」の命令となります。<BR>
　「$1」「$2」「$3」「$4」は、それぞれから「$$」までを、<b>アドレスコーディング表記の文字列</b>と見なし、数値へと変換処理します。（詳しいアドレスコーディングの書き方は、<A HREF="index.htm">《A-アドレス》</a>を参照。）さらにその数値を、「$1」ならば1バイト分のバイト列（00〜FF）に、「$2」ならば2バイト分の文字列（0000〜FFFF）に、といった具合に、<font color="#FF0000">指定したバイト数のバイト列</font>へと置き換える命令になります。<BR>
　ここでは、アドレス0x400000の4バイトの値に0x500を加算した値を、4バイト分のバイト列として利用しています。<BR>
　なお、バイト列は2文字単位が原則ですが、アドレスコーディング部分は、自由に書いて構いません。
</td></tr>
</table>
</td></tr>
<tr><td CLASS=flameTD NOWRAP>*{ FF :: 01 *}</td><td>
<table class="difficultBOX">
<tr><td class="difficultLevel">難解度「AA+」</td></tr>
<tr><td>
"*{"は、条件付き置換命令です。　
<table CLASS=exaBOX><tr><td NOWRAP>
*{ 条件式のバイト列 :: 真のとき処理するバイト列<br>
　　　　　　　　　　:: 偽のとき処理するバイト列 *}<br>
<FONT 
color=#c06000>////////////////////　↑実際は一行で書きます</FONT>
</td></tr></table>
という書式で書きます。条件分岐（経路分岐）命令と非常に似ていますが、<b>条件式を評価した結果、次に読み書きするアドレス</b>に差があります。
　<font color="#0000FF">あるアドレスの値がFFなら、そのアドレスの値を01に書き換えたい</font>といった処理をバイト列で行うとき、条件分岐命令(*{::*})では非常に分かりづらい書き方をしなくてはなりません。そこを簡潔に処理できるのが、この条件付き置換命令です。<br>
　仮に処理開始のアドレスを0x400000 とすると、ここでは、
アドレス0x400000 の値がFF であれば、
アドレス0x400000 に01 を処理する。というバイト列になります。（FFでない場合は、何もしません）<BR>
　なお、現在ON(真)であるかOFF(偽)であるかの判定時には、真のバイト列で評価します。このため、書き込みを指示しても、対象位置の値が条件式で真とならない場合は、真の値が書き込まれず、当然、再評価時にもON(真)とはならないので注意。
</td></tr>
</table>
</td></tr>
<tr><td CLASS=flameTD NOWRAP>*{ FF :: 01 :: FF *}</td><td>
条件式の偽の処理も行う場合の例です。<BR>
仮に処理開始のアドレスを0x400000 とすると、ここでは、<BR>
アドレス0x400000 の値がFF であれば、<BR>
アドレス0x400000 に01 を処理し、FF でないなら<BR>
アドレス0x400000 にFF を処理する。というバイト列になります。
</td></tr>
<tr><td CLASS=flameTD NOWRAP>*[ 0x20 :: FF00 *]</td><td>
<table class="difficultBOX">
<tr><td class="difficultLevel">難解度「AA+」</td></tr>
<tr><td>
"*["は、反復命令です。
<table CLASS=exaBOX><tr><td NOWRAP>
*[ 反復サイズのアドレス式 :: 反復するバイト列 *]
</td></tr></table>
という書式で書きます。あるバイト列を、必要回数分繰り返したい、という場合に使用します。（簡易的なFOR構文）<br>
　<font color="#0000FF">「反復サイズのアドレス式」</font>には、反復する総バイトサイズを、アドレス式で書きます。仮に8を指定したとすれば、8バイト反復します。もし、<font color="#FF0000">「反復するバイト列」</font>が6バイト分だった場合、生成されるバイト列は、1回反復分の6バイト＋最初の2バイト分となります。アドレス式なので、頭に'_'を付ければ、アドレスコーディングを用いることもできます。詳しいアドレスの書き方は、<A HREF="../0A/index.htm">《A-アドレス》</a>を参照。<br>
　<font color="#FF0000">「反復するバイト列」</font>には、文字通り繰り返したいバイト列を指定して下さい。
</td></tr>
</table>
</td></tr>
<tr><td CLASS=flameTD NOWRAP>&lt;_ A020 :: FFCC _&gt;</td><td>
　"&lt;_"は、マスクバイト命令です。<br>
　バイト列は原則として16進数表記のため、<b>F?</b>や<b>?A</b>のように、上位・下位8ビット単位でしかマスク指定ができません。これを1ビット単位で行いたい場合は、ビット展開命令(*_)を用いるのですが、対象が数バイトに及ぶ場合、非常に分かりにくくなります。そんなときは、このマスクバイト命令を用います。<BR>
<table CLASS=exaBOX><tr><td NOWRAP>
&lt;_ マスクバイト列 :: 処理バイト列 _&gt;
</td></tr></table>
　という書式を用います。<br>
　これによって、処理バイト列をマスクバイト列でマスクした書き込みが行えます。ただし、「マスクバイト列」および「処理バイト列」は、純粋な2文字単位の16進数でなければなりません。<font color="#FF0000">?やその他の命令を埋め込むことはできません。</font>
</td></tr>
</table>
<BR>
　ジャンプ命令や条件分岐命令など、少々理解に苦しむところもあるかとは思いますが、使いこなせば結構複雑な処理もバイト列だけで記述することが出来ます。ま、それでも普通は「2EFFC0E0」などの、単純なバイト数値で事足りるでしょうけども(^^;

</td></tr>
</TABLE>
　


</TD></TR></TABLE><BR>
<BR>



<BR>
<BR>
<A HREF="01.htm">ねくすと　せくしょん⇒</A>
<BR>
<BR>
<A HREF="index.htm">≪せくしょん　ばっく</A>
<P><BR></P>


</body></html>